/* ---------------Seccion de declaraciones preliminares--------------------*/
package parser.data;

/* Import the class java_cup.runtime.*  */
import java_cup.runtime.*;
import java.io.FileReader;
   
/* Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores. */
parser code {:

    public static Lexer s;
    public static int errors = 0;
    public static ErrorData errorData = ErrorData.getInstance();
    ErrorData detectedError;
    
    public void unrecovered_syntax_error(Symbol cur_token){
        if(cur_token.sym == 0){
            System.out.println("*******************FIN DEL ANALISIS**********************");
        }
        else{
            report_error("Error fatal","");
        }
    }
    /* Reporte de error encontrado. */
    public void report_error(String message, Object info) {
        if (info instanceof String){
            errors++;
            /*try {
                restart_lookahead();
            } catch (Exception ex) {
                Logger.getLogger(Parser.class.getName()).log(Level.SEVERE, null, ex);
            }*/
            String mensaje = ", se esperaba: " + message;
            try{
                detectedError.setId(errors);
            }catch(Exception e){
                detectedError = new ErrorData(errors, info.toString(), mensaje);
            }
            detectedError.setMessage(detectedError.getMessage() + mensaje);
            errorData.insertarError(detectedError);
        }
        else {
            StringBuilder m = new StringBuilder("Error");
            if (info instanceof java_cup.runtime.Symbol) {
                java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
                if (s.left >= 0) {                
                    m.append(" en la línea "+(s.left+1));
                    if (s.right >= 0)
                        m.append(", columna "+(s.right+1));
                }
            }
            m.append(" : " + message);
            detectedError = new ErrorData(errors, info.toString(), m.toString());
            errorData.insertarError(detectedError);
            if(info.toString().equals("#" + 0))
                done_parsing();
        }
    }
   
    /* Cuando se encuentra un error de donde el sistema no puede
        recuperarse, se lanza un error fatal. Se despliega el mensaje
        de error y se finaliza la ejecucion. */
    public void report_fatal_error(String message, Object info) {
        System.out.println("----------FUI YO------------");
        report_error(message, info);
        //System.exit(1);
    }

    /* Metodo main para garantizar la ejecucion del analizador
       lexico y sintactico, ademas que se pase como parametro la tabla
       de simbolos correspondiente. */
    public static void main(String[] args){
        try {
            s = new Lexer(new FileReader(args[0]));
            Parser p = new Parser(s);
            p.parse();
            System.out.println("\n*** Fin del parseo ***");
            System.out.println("Total de errores = " + errors + ".");
            errors = 0;
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
:};
   

   
/* ------------Declaracion de simbolos terminales y no terminales---------- */

/* OPERADORES */
terminal            ADD, SUBSTRACT, TIMES, DIVISION, MODULUS;
terminal            PLUSPLUS, MINUSMINUS;
terminal            ASSIGN, PLUSEQ, MINUSEQ, TIMESEQ, DIVEQ, MODEQ;

/* SEPARADORES */
terminal            LPAREN, RPAREN, LBRACE, RBRACE, SEMICOLON, COLON, COMMA;

/* SENTENCIAS */
terminal            IF, ELSE, WHILE, DO, FOR, SWITCH;

/* COMPARADORES */
terminal            EQUAL, MENORQUE,MENOREQ, MAYORQUE, MAYOREQ, EXCLAMACION, NOTEQ, OR, AND;

/* PALABRAS RESERVADAS */
terminal            CASE, DEFAULT, RETURN, CONTINUE, BREAK, VOID;

/* FUNCIONES */
terminal            READ,WRITE;

/* TIPOS */
terminal            INT, CHAR, LONG, SHORT, CONST;
terminal Integer    LITERAL_ENTERO;
terminal            LITERAL_CARACTER;
terminal String     LITERAL_STRING;

/* IDENTIFICADOR */
terminal            IDENTIFICADOR;

/* EOF*/

non terminal            inicio, programa_c , def_funcion , funcion , lista_parametros , parametro;
non terminal            read_f,write_f, write_f_aux;
non terminal            bloque_global, bloque, lista_sentencias, sentencia, expresion;
non terminal            asignacion, exp, op_asignaciones, call_function, call_function_aux;
non terminal            if_statement, while_statement, dowhile_statement, for_statement, else_statement, break_stmt, continue_stmt, return_stmt;
non terminal            condicion, valor;
non terminal            switch_stmt, case_body, lista_case, case_stmt, default_stmt;
non terminal            tipo_dato, short_stmt, long_stmt, long_stmt_aux, declaracion_var, lista_ids;
non terminal            decision_funcion, decision_operacion, validar_expr, declaracion_var_interna;
non terminal            condicion_for, tipo_for, inicio_for, medio_for, fin_for;
non terminal            operacion_bin_1, operacion_bin_2, operador, comparador, condicion_2, is_constante;
non terminal            unexpected_assignment, lista_sentencias_aux, expresion_manejo;

precedence left OR, AND;
precedence left ADD, SUBSTRACT;
precedence left TIMES, DIVISION, MODULUS;

/* ------------------- Seccion de la gramatica ------------------------ */
    start with inicio;

    inicio              ::= programa_c;

    programa_c          ::=   tipo_dato declaracion_var programa_c | CONST tipo_dato declaracion_var programa_c
                            | decision_funcion;
    
    decision_funcion    ::= tipo_dato IDENTIFICADOR decision_operacion decision_funcion
                            | VOID IDENTIFICADOR decision_operacion decision_funcion 
                            | VOID error {: parser.report_error(" el identificador de la función.","");  :} decision_operacion decision_funcion
                            | error {: parser.report_error(" tipo de dato de la función.","");  :} IDENTIFICADOR decision_operacion decision_funcion
                            | error {: parser.report_error(" el identificador de la función.","");  :} decision_operacion decision_funcion;

    decision_operacion   ::= def_funcion | funcion;

    def_funcion         ::= LPAREN lista_parametros RPAREN SEMICOLON;
    
    funcion             ::= LPAREN lista_parametros RPAREN bloque_global | 
                            LPAREN error {: parser.report_error(" parámetro incorrecto.",""); :} RPAREN bloque_global;

    lista_parametros    ::= lista_parametros COMMA parametro | parametro | ;

    parametro           ::= tipo_dato IDENTIFICADOR;

    bloque_global       ::= LBRACE declaracion_var_interna lista_sentencias RBRACE 
                            | LBRACE RBRACE
                            | error {: parser.report_error(" no se encuentra el LBRACE .","");  :} programa_c;
                            //| LBRACE declaracion_var_interna lista_sentencias error {: parser.report_error(" no se encuentra el RBRACE .","");  :} programa_c;

    bloque              ::= LBRACE lista_sentencias RBRACE | LBRACE RBRACE | 
                            error {: parser.report_error(" no se encuentra el LBRACE o expresión inválida.","");  :} decision_funcion;

    declaracion_var_interna     ::= is_constante tipo_dato declaracion_var declaracion_var_interna | ;

    lista_sentencias    ::= lista_sentencias sentencia | sentencia;

    sentencia           ::= if_statement |  while_statement | dowhile_statement | switch_stmt | for_statement |
                            expresion SEMICOLON | break_stmt | continue_stmt | return_stmt |
                            error {: parser.report_error(" no se reconoce la expresión o falta ; al final.", "");  :} sentencia;
 
    expresion           ::=  exp | EXCLAMACION exp | call_function | asignacion;
    
    asignacion          ::= IDENTIFICADOR op_asignaciones exp;

    op_asignaciones     ::= ASSIGN | operacion_bin_2;

    exp                 ::= valor operador expresion |valor comparador expresion | LPAREN expresion RPAREN
                            | valor;
    call_function       ::= IDENTIFICADOR LPAREN call_function_aux RPAREN | IDENTIFICADOR LPAREN RPAREN | read_f | write_f ;
    
    call_function_aux   ::= call_function_aux COMMA expresion |  expresion;

    is_constante        ::= CONST | ;
            
    condicion           ::= condicion_2 AND condicion | condicion_2 OR condicion | condicion_2;

    condicion_2         ::= expresion;

    read_f              ::= READ LPAREN IDENTIFICADOR RPAREN | READ LPAREN RPAREN | 
                            READ LPAREN error{: parser.report_error(" parámetros incorrectos en el READ.", ""); :} RPAREN;

    write_f             ::= WRITE LPAREN write_f_aux RPAREN |
                            WRITE LPAREN error{: parser.report_error(" parámetros incorrectos en el WRITE.", ""); :} RPAREN;

    write_f_aux         ::= write_f_aux COMMA expresion | expresion; 
        
    if_statement        ::= IF LPAREN condicion RPAREN bloque else_statement |
                            IF LPAREN 
                                error {: parser.report_error(" una condición válida para el IF.", ""); :} 
                            RPAREN bloque else_statement |
                            IF LPAREN
                                    error {: parser.report_error(" un RPAREN al final de la condición del IF.", ""); :} 
                            bloque| 
                            IF  
                                error {: parser.report_error(" un LPAREN al final de la condición del IF.", ""); :} 
                            RPAREN bloque else_statement;

    else_statement      ::= ELSE bloque |;

    while_statement     ::= WHILE LPAREN condicion RPAREN bloque|
                            WHILE LPAREN
                                error {: parser.report_error("una condición valida para el WHILE.", ""); :} 
                            RPAREN bloque|
                            WHILE LPAREN
                                error {: parser.report_error(" un RPAREN al final de la condición del WHILE.", ""); :} 
                            bloque
                            | WHILE 
                                error {: parser.report_error(" un LPAREN al final de la condición del WHILE.", ""); :} 
                            RPAREN bloque;

    dowhile_statement   ::= DO bloque WHILE LPAREN condicion RPAREN SEMICOLON |
                            DO bloque WHILE LPAREN
                                error {: parser.report_error(" una condición valida para el DO_WHILE.", ""); :} 
                            RPAREN SEMICOLON|
                            DO bloque WHILE LPAREN
                                error {: parser.report_error(" un RPAREN al final de la condición del DO_WHILE.", ""); :} 
                            SEMICOLON
                            | DO bloque WHILE 
                                error {: parser.report_error(" un LPAREN al final de la condición del DO_WHILE.", ""); :} 
                            RPAREN SEMICOLON;
 
    for_statement       ::= FOR LPAREN condicion_for RPAREN tipo_for |
                            FOR LPAREN 
                                error {: parser.report_error(" una condición valida para el FOR.", ""); :}  
                            RPAREN tipo_for|
                            FOR 
                                error {: parser.report_error(" un LPAREN al final de la condición del FOR.", ""); :}  
                            RPAREN tipo_for|
                            FOR LPAREN 
                                error {: parser.report_error(" un RPAREN al final de la condición del FOR.", ""); :}  
                             tipo_for;
    
    tipo_for            ::= bloque | SEMICOLON;

    condicion_for       ::= inicio_for SEMICOLON medio_for SEMICOLON fin_for ;
    
    inicio_for          ::= asignacion | ;

    medio_for           ::= IDENTIFICADOR comparador valor | ;

    fin_for             ::= IDENTIFICADOR operacion_bin_1 | IDENTIFICADOR operacion_bin_2 valor | 
                            IDENTIFICADOR ASSIGN IDENTIFICADOR operador valor |;

    switch_stmt         ::= SWITCH LPAREN valor RPAREN LBRACE case_body RBRACE |
                            SWITCH LPAREN 
                                error {: parser.report_error("una condición numérica para el SWITCH.", ""); :}  
                            RPAREN LBRACE case_body RBRACE |
                            SWITCH 
                                error {: parser.report_error(" un LPAREN al final de la condición del SWITCH.", ""); :}  
                            RPAREN LBRACE case_body RBRACE|
                            SWITCH LPAREN
                                error {: parser.report_error(" un RPAREN al final de la condición del SWITCH.", ""); :}  
                            LBRACE case_body RBRACE;
    
    case_body           ::= lista_case | lista_case default_stmt |;
    
    lista_case          ::= case_stmt | case_stmt break_stmt | lista_case case_stmt;
    
    case_stmt           ::= CASE valor COLON sentencia | CASE valor COLON LPAREN lista_sentencias RPAREN;
    
    default_stmt        ::= DEFAULT COLON sentencia | DEFAULT COLON LPAREN lista_sentencias RPAREN;
       
    break_stmt         ::= BREAK SEMICOLON;

    continue_stmt      ::= CONTINUE SEMICOLON;
    
    return_stmt         ::= RETURN expresion SEMICOLON;

    tipo_dato           ::= INT | CHAR | short_stmt | long_stmt;

    declaracion_var     ::= lista_ids SEMICOLON;

    lista_ids           ::=  IDENTIFICADOR validar_expr | 
                             lista_ids COMMA IDENTIFICADOR validar_expr | 
                             lista_ids IDENTIFICADOR validar_expr |
                             error{: parser.report_error(" un ; al final de la expresión.",""); :} programa_c;

    short_stmt          ::= SHORT | SHORT INT;

    long_stmt           ::= LONG LONG long_stmt_aux | LONG long_stmt_aux;

    long_stmt_aux       ::= INT | ;

    validar_expr        ::= ASSIGN expresion
                            | ASSIGN error {: parser.report_error(" una expresión o falta ; al final.",""); :} programa_c
                            |;

    comparador          ::= EQUAL | NOTEQ  | MENOREQ | MAYOREQ | MENORQUE | MAYORQUE;

    operador            ::= ADD | SUBSTRACT | TIMES | DIVISION | MODULUS;

    operacion_bin_1     ::= PLUSPLUS | MINUSMINUS;

    operacion_bin_2     ::= MINUSEQ | TIMESEQ | PLUSEQ | DIVEQ | MODEQ;

    valor               ::= IDENTIFICADOR | LITERAL_ENTERO | LITERAL_CARACTER | SUBSTRACT LITERAL_ENTERO;