/* ---------------Seccion de declaraciones preliminares--------------------*/
package parser.data;

/* Import the class java_cup.runtime.*  */
import java_cup.runtime.*;
import java.io.FileReader;
   
/* Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores. */
parser code {:
    /* Reporte de error encontrado. */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" en la lÃ­nea "+(s.left+1));
                if (s.right >= 0)
                    m.append(", columna "+(s.right+1));
            }
        }
        m.append(" : " + message);
        System.out.println(m);
    }
   
    /* Cuando se encuentra un error de donde el sistema no puede
        recuperarse, se lanza un error fatal. Se despliega el mensaje
        de error y se finaliza la ejecucion. */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

    /* Metodo main para garantizar la ejecucion del analizador
       lexico y sintactico, ademas que se pase como parametro la tabla
       de simbolos correspondiente. */
    public static void main(String[] args){
        try {
            Parser p = new Parser(
                    new Lexer( new FileReader(args[0])));
            Object result = p.parse().value;
            System.out.println("\n*** Resultados finales ***");
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
:};
   

   
/* ------------Declaracion de simbolos terminales y no terminales---------- */

/* OPERADORES */
terminal            ADD, SUBSTRACT, TIMES, DIVISION, MODULUS;
terminal            PLUSPLUS, MINUSMINUS;
terminal            ASSIGN, PLUSEQ, MINUSEQ, TIMESEQ, DIVEQ, MODEQ;

/* SEPARADORES */
terminal            LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK, SEMICOLON, COL, COMMA, DOT;

/* SENTENCIAS */
terminal            IF, ELSE, WHILE, DO, FOR, SWITCH;

/* COMPARADORES */
terminal            EQUAL, MENORQUE,MENOREQ, MAYORQUE, MAYOREQ, EXCLAMACION, NOTEQ, OR, AND;

/* PALABRAS RESERVADAS */
terminal            CASE, DEFAULT, RETURN, CONTINUE, BREAK, VOID;

/* FUNCIONES */
terminal            READ,WRITE;

/* TIPOS */
terminal            INT, CHAR, LONG, SHORT, CONST;
terminal Integer    LITERAL_ENTERO;
terminal            LITERAL_CARACTER;
terminal String     LITERAL_STRING;

/* IDENTIFICADOR */
terminal            IDENTIFICADOR;

/* DIRECTIVAS */
terminal            SIMBOLO_NUMERO, INCLUDE, TEXTO_DIRECTIVA;


non terminal            inicio, programa_c , def_funcion , funcion , lista_parametros , parametro;
non terminal            read_f,write_f, read_f_aux, write_f_aux;
non terminal            bloque_global, bloque, lista_sentencias, sentencia, expresion;
non terminal            asignacion, exp_aritmetica,op_asignaciones, exp_booleana, ea1;
non terminal            if_statement, while_statement, dowhile_statement, for_statement, else_statement;
non terminal            condicion, valor;
non terminal            switch_stmt, case_body, lista_case, case_stmt, default_stmt;
non terminal            tipo_dato, short_stmt, long_stmt, long_stmt_fase1, long_stmt_fase2, declaracion_var, lista_ids;
non terminal            validar_int, validar_char, directiva, contenido_directiva, decision_funcion, decision_operacion, validar_expr;
non terminal            condicion_for, tipo_for, inicio_for, medio_for, fin_for, validar_expr_2;
non terminal            operacion_bin_1, operacion_bin_2, operador, comparador, condicion_2, is_constante;

/* ------------------- Seccion de la gramatica ------------------------ */
   
    inicio              ::= programa_c;

    programa_c          ::=  VOID IDENTIFICADOR decision_funcion programa_c |
                            is_constante tipo_dato IDENTIFICADOR decision_operacion programa_c |
                            directiva programa_c |;

    decision_funcion    ::= def_funcion | funcion;

    decision_operacion   ::= def_funcion | funcion | declaracion_var;

    directiva           ::= SIMBOLO_NUMERO INCLUDE contenido_directiva;

    contenido_directiva ::= LITERAL_STRING | TEXTO_DIRECTIVA;

    def_funcion         ::= LPAREN lista_parametros RPAREN SEMICOLON;
    
    funcion             ::= LPAREN lista_parametros RPAREN bloque;

    lista_parametros    ::= lista_parametros COMMA parametro | parametro |;

    parametro           ::= tipo_dato IDENTIFICADOR;

    bloque_global       ::= bloque;

    bloque              ::= LBRACE lista_sentencias RBRACE | LBRACE RBRACE ;

    lista_sentencias    ::= lista_sentencias sentencia | sentencia; ///| expresion SEMICOLON;

    sentencia           ::= if_statement |  while_statement | dowhile_statement | switch_stmt | for_statement |
                            is_constante tipo_dato IDENTIFICADOR declaracion_var | read_f | write_f |RETURN valor SEMICOLON;

    /*expresion           ::= asignacion  | exp_aritmetica  | exp_booleana ;
    
    asignacion          ::= IDENTIFICADOR op_asignaciones expresion;

    op_asignaciones     ::= ASSIGN | PLUSEQ | MINUSEQ | TIMESEQ | DIVEQ | MODEQ;

    exp_aritmetica      ::= LPAREN exp_aritmetica RPAREN ea1 | valor ea1 ;

    ea1                 ::= operador exp_aritmetica ea1 | ;

    exp_booleana        ::= condicion | LPAREN exp_booleana RPAREN;*/

    if_statement        ::= IF LPAREN condicion RPAREN bloque_global else_statement 
                            |
                            IF condicion bloque_global;

    /*PONER TODOS LOS LITERALES*/
    valor               ::= IDENTIFICADOR | LITERAL_ENTERO | LITERAL_CARACTER | SUBSTRACT LITERAL_ENTERO;
                                    
    condicion           ::= valor comparador valor condicion_2
                            |
                            valor condicion_2
                            |
                            error:e
                            {: 
                            :};
    
    condicion_2         ::= AND condicion | OR condicion |;

    else_statement      ::= ELSE bloque_global;

    read_f              ::= READ LPAREN read_f_aux RPAREN SEMICOLON;
    
    read_f_aux          ::= IDENTIFICADOR  | ;

    write_f             ::= WRITE LPAREN write_f_aux RPAREN SEMICOLON;

    write_f_aux         ::= write_f_aux COMMA valor | valor; 

    while_statement     ::= WHILE LPAREN condicion RPAREN bloque_global;

    dowhile_statement   ::= DO bloque_global WHILE LPAREN condicion RPAREN SEMICOLON;

    for_statement       ::= FOR LPAREN condicion_for RPAREN tipo_for;

    condicion_for       ::= inicio_for SEMICOLON medio_for SEMICOLON fin_for;
    
    inicio_for          ::= IDENTIFICADOR ASSIGN valor | ;

    medio_for           ::= IDENTIFICADOR comparador valor | ;

    fin_for             ::= IDENTIFICADOR operacion_bin_1 | IDENTIFICADOR operacion_bin_2 valor | 
                            IDENTIFICADOR ASSIGN IDENTIFICADOR operador valor |;

    comparador          ::= EQUAL | NOTEQ  | MENOREQ | MAYOREQ | MENORQUE | MAYORQUE; // QUITE | EXCLAMACION

    operador            ::= ADD | SUBSTRACT | TIMES | DIVISION | MODULUS;

    operacion_bin_1     ::= PLUSPLUS | MINUSMINUS;

    operacion_bin_2     ::= MINUSEQ | TIMESEQ | PLUSEQ | DIVEQ | MODEQ;

    tipo_for            ::= bloque | SEMICOLON;

    switch_stmt         ::= SWITCH LPAREN valor RPAREN LBRACE case_body RBRACE; 
    
    case_body           ::= lista_case | lista_case default_stmt;
    
    lista_case          ::= case_stmt | lista_case case_stmt;
    
    case_stmt           ::= CASE valor COL sentencia | CASE valor COL LPAREN lista_sentencias RPAREN;
    
    default_stmt        ::= DEFAULT COL sentencia | DEFAULT COL LPAREN lista_sentencias RPAREN;
    
    tipo_dato           ::= INT | CHAR | short_stmt | long_stmt;

    declaracion_var     ::= is_constante lista_ids SEMICOLON;

    is_constante        ::= CONST | ;
    
    lista_ids           ::= IDENTIFICADOR validar_expr |  lista_ids COMMA IDENTIFICADOR validar_expr | validar_expr;

    short_stmt          ::= SHORT | SHORT INT;

    long_stmt           ::= LONG long_stmt_fase1;

    long_stmt_fase1     ::= INT | LONG long_stmt_fase2 | ;

    long_stmt_fase2     ::= INT |;

    validar_expr        ::= ASSIGN validar_expr_2 |;

    validar_expr_2      ::= LITERAL_ENTERO | LITERAL_CARACTER;